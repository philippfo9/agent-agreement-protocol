/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseAddPartyInstruction,
  parseCancelAgreementInstruction,
  parseCloseAgreementInstruction,
  parseFulfillAgreementInstruction,
  parseProposeAgreementInstruction,
  parseRegisterAgentInstruction,
  parseRegisterSubAgentInstruction,
  parseRevokeAgentInstruction,
  parseSignAgreementInstruction,
  parseUpdateDelegationInstruction,
  type ParsedAddPartyInstruction,
  type ParsedCancelAgreementInstruction,
  type ParsedCloseAgreementInstruction,
  type ParsedFulfillAgreementInstruction,
  type ParsedProposeAgreementInstruction,
  type ParsedRegisterAgentInstruction,
  type ParsedRegisterSubAgentInstruction,
  type ParsedRevokeAgentInstruction,
  type ParsedSignAgreementInstruction,
  type ParsedUpdateDelegationInstruction,
} from "../instructions";

export const AGENT_AGREEMENT_PROTOCOL_PROGRAM_ADDRESS =
  "4G1njguyZNtTTrwoRjTah8MeNGjwNyEsTbA2198sJkDe" as Address<"4G1njguyZNtTTrwoRjTah8MeNGjwNyEsTbA2198sJkDe">;

export enum AgentAgreementProtocolAccount {
  AgentIdentity,
  Agreement,
  AgreementParty,
}

export function identifyAgentAgreementProtocolAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): AgentAgreementProtocolAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([11, 149, 31, 27, 186, 76, 241, 72]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolAccount.AgentIdentity;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 212, 5, 110, 225, 249, 197, 84]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolAccount.Agreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([126, 203, 208, 120, 149, 204, 109, 16]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolAccount.AgreementParty;
  }
  throw new Error(
    "The provided account could not be identified as a agentAgreementProtocol account.",
  );
}

export enum AgentAgreementProtocolInstruction {
  AddParty,
  CancelAgreement,
  CloseAgreement,
  FulfillAgreement,
  ProposeAgreement,
  RegisterAgent,
  RegisterSubAgent,
  RevokeAgent,
  SignAgreement,
  UpdateDelegation,
}

export function identifyAgentAgreementProtocolInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): AgentAgreementProtocolInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([140, 77, 36, 36, 64, 148, 34, 149]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.AddParty;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([75, 89, 85, 4, 100, 216, 143, 37]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.CancelAgreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([48, 34, 42, 18, 144, 209, 198, 55]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.CloseAgreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([137, 43, 47, 162, 147, 240, 236, 5]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.FulfillAgreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([225, 187, 165, 37, 49, 191, 189, 11]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.ProposeAgreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([135, 157, 66, 195, 2, 113, 175, 30]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.RegisterAgent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([218, 146, 50, 162, 93, 32, 5, 151]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.RegisterSubAgent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([227, 60, 209, 125, 240, 117, 163, 73]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.RevokeAgent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([113, 163, 162, 101, 44, 101, 65, 204]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.SignAgreement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 91, 130, 42, 18, 37, 155, 70]),
      ),
      0,
    )
  ) {
    return AgentAgreementProtocolInstruction.UpdateDelegation;
  }
  throw new Error(
    "The provided instruction could not be identified as a agentAgreementProtocol instruction.",
  );
}

export type ParsedAgentAgreementProtocolInstruction<
  TProgram extends string = "4G1njguyZNtTTrwoRjTah8MeNGjwNyEsTbA2198sJkDe",
> =
  | ({
      instructionType: AgentAgreementProtocolInstruction.AddParty;
    } & ParsedAddPartyInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.CancelAgreement;
    } & ParsedCancelAgreementInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.CloseAgreement;
    } & ParsedCloseAgreementInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.FulfillAgreement;
    } & ParsedFulfillAgreementInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.ProposeAgreement;
    } & ParsedProposeAgreementInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.RegisterAgent;
    } & ParsedRegisterAgentInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.RegisterSubAgent;
    } & ParsedRegisterSubAgentInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.RevokeAgent;
    } & ParsedRevokeAgentInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.SignAgreement;
    } & ParsedSignAgreementInstruction<TProgram>)
  | ({
      instructionType: AgentAgreementProtocolInstruction.UpdateDelegation;
    } & ParsedUpdateDelegationInstruction<TProgram>);

export function parseAgentAgreementProtocolInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedAgentAgreementProtocolInstruction<TProgram> {
  const instructionType =
    identifyAgentAgreementProtocolInstruction(instruction);
  switch (instructionType) {
    case AgentAgreementProtocolInstruction.AddParty: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.AddParty,
        ...parseAddPartyInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.CancelAgreement: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.CancelAgreement,
        ...parseCancelAgreementInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.CloseAgreement: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.CloseAgreement,
        ...parseCloseAgreementInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.FulfillAgreement: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.FulfillAgreement,
        ...parseFulfillAgreementInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.ProposeAgreement: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.ProposeAgreement,
        ...parseProposeAgreementInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.RegisterAgent: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.RegisterAgent,
        ...parseRegisterAgentInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.RegisterSubAgent: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.RegisterSubAgent,
        ...parseRegisterSubAgentInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.RevokeAgent: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.RevokeAgent,
        ...parseRevokeAgentInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.SignAgreement: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.SignAgreement,
        ...parseSignAgreementInstruction(instruction),
      };
    }
    case AgentAgreementProtocolInstruction.UpdateDelegation: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: AgentAgreementProtocolInstruction.UpdateDelegation,
        ...parseUpdateDelegationInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
